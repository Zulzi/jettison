// Code generated by protocp; DO NOT EDIT.
package internal

import (
	"github.com/luno/jettison/internal/jettisonpb"
	"github.com/luno/jettison/models"
)

func HopToProto(namedInput *models.Hop) (*jettisonpb.Hop, error) {
	var namedOutput *jettisonpb.Hop

	var tmpInput *models.Hop
	var tmpInput1 models.Hop

	var tmpOutput1 jettisonpb.Hop
	var tmpOutput *jettisonpb.Hop

	var inputIsNil bool
	tmpInput = namedInput
	if tmpInput != nil {
		tmpInput1 = *tmpInput
	} else {
		inputIsNil = true
	}

	if !inputIsNil {
		tmpOutput1.Binary = tmpInput1.Binary
		for i := range tmpInput1.Errors {
			var tmpOutput2 *jettisonpb.Error

			var tmpInput2 models.Error

			var tmpOutput4 jettisonpb.Error
			var tmpOutput3 *jettisonpb.Error

			var inputIsNil1 bool
			tmpInput2 = tmpInput1.Errors[i]

			if !inputIsNil1 {
				tmpOutput4.Code = tmpInput2.Code
				tmpOutput4.Message = tmpInput2.Message
				for i1 := range tmpInput2.Parameters {
					var tmpOutput5 *jettisonpb.KeyValue

					var tmpInput3 models.KeyValue

					var tmpOutput7 jettisonpb.KeyValue
					var tmpOutput6 *jettisonpb.KeyValue

					var inputIsNil2 bool
					tmpInput3 = tmpInput2.Parameters[i1]

					if !inputIsNil2 {
						tmpOutput7.Key = tmpInput3.Key
						tmpOutput7.Value = tmpInput3.Value

						tmpOutput6 = &tmpOutput7

					}

					tmpOutput5 = tmpOutput6
					tmpOutput4.Parameters = append(tmpOutput4.Parameters, tmpOutput5)
				}
				tmpOutput4.Source = tmpInput2.Source

				tmpOutput3 = &tmpOutput4

			}

			tmpOutput2 = tmpOutput3
			tmpOutput1.Errors = append(tmpOutput1.Errors, tmpOutput2)
		}
		tmpOutput1.StackTrace = ([]string)(tmpInput1.StackTrace)

		tmpOutput = &tmpOutput1

	}

	namedOutput = tmpOutput

	return namedOutput, nil
}

func HopFromProto(namedInput *jettisonpb.Hop) (*models.Hop, error) {
	var namedOutput *models.Hop

	var tmpInput *jettisonpb.Hop
	var tmpInput1 jettisonpb.Hop

	var tmpOutput1 models.Hop
	var tmpOutput *models.Hop

	var inputIsNil bool
	tmpInput = namedInput
	if tmpInput != nil {
		tmpInput1.Binary = tmpInput.Binary
		tmpInput1.StackTrace = tmpInput.StackTrace
		tmpInput1.Errors = tmpInput.Errors
	} else {
		inputIsNil = true
	}

	if !inputIsNil {
		tmpOutput1.Binary = tmpInput1.Binary
		for i := range tmpInput1.Errors {
			var tmpOutput2 models.Error

			var tmpInput2 *jettisonpb.Error
			var tmpInput3 jettisonpb.Error

			var tmpOutput3 models.Error

			var inputIsNil1 bool
			tmpInput2 = tmpInput1.Errors[i]
			if tmpInput2 != nil {
				tmpInput3.Code = tmpInput2.Code
				tmpInput3.Message = tmpInput2.Message
				tmpInput3.Source = tmpInput2.Source
				tmpInput3.Parameters = tmpInput2.Parameters
			} else {
				inputIsNil1 = true
			}

			if !inputIsNil1 {
				tmpOutput3.Code = tmpInput3.Code
				tmpOutput3.Message = tmpInput3.Message
				for i1 := range tmpInput3.Parameters {
					var tmpOutput4 models.KeyValue

					var tmpInput4 *jettisonpb.KeyValue
					var tmpInput5 jettisonpb.KeyValue

					var tmpOutput5 models.KeyValue

					var inputIsNil2 bool
					tmpInput4 = tmpInput3.Parameters[i1]
					if tmpInput4 != nil {
						tmpInput5.Key = tmpInput4.Key
						tmpInput5.Value = tmpInput4.Value
					} else {
						inputIsNil2 = true
					}

					if !inputIsNil2 {
						tmpOutput5.Key = tmpInput5.Key
						tmpOutput5.Value = tmpInput5.Value

					}

					tmpOutput4 = tmpOutput5
					tmpOutput3.Parameters = append(tmpOutput3.Parameters, tmpOutput4)
				}
				tmpOutput3.Source = tmpInput3.Source

			}

			tmpOutput2 = tmpOutput3
			tmpOutput1.Errors = append(tmpOutput1.Errors, tmpOutput2)
		}
		tmpOutput1.StackTrace = ([]string)(tmpInput1.StackTrace)

		tmpOutput = &tmpOutput1

	}

	namedOutput = tmpOutput

	return namedOutput, nil
}

func ErrorToProto(namedInput *models.Error) (*jettisonpb.Error, error) {
	var namedOutput *jettisonpb.Error

	var tmpInput *models.Error
	var tmpInput1 models.Error

	var tmpOutput1 jettisonpb.Error
	var tmpOutput *jettisonpb.Error

	var inputIsNil bool
	tmpInput = namedInput
	if tmpInput != nil {
		tmpInput1 = *tmpInput
	} else {
		inputIsNil = true
	}

	if !inputIsNil {
		tmpOutput1.Code = tmpInput1.Code
		tmpOutput1.Message = tmpInput1.Message
		for i := range tmpInput1.Parameters {
			var tmpOutput2 *jettisonpb.KeyValue

			var tmpInput2 models.KeyValue

			var tmpOutput4 jettisonpb.KeyValue
			var tmpOutput3 *jettisonpb.KeyValue

			var inputIsNil1 bool
			tmpInput2 = tmpInput1.Parameters[i]

			if !inputIsNil1 {
				tmpOutput4.Key = tmpInput2.Key
				tmpOutput4.Value = tmpInput2.Value

				tmpOutput3 = &tmpOutput4

			}

			tmpOutput2 = tmpOutput3
			tmpOutput1.Parameters = append(tmpOutput1.Parameters, tmpOutput2)
		}
		tmpOutput1.Source = tmpInput1.Source

		tmpOutput = &tmpOutput1

	}

	namedOutput = tmpOutput

	return namedOutput, nil
}

func ErrorFromProto(namedInput *jettisonpb.Error) (*models.Error, error) {
	var namedOutput *models.Error

	var tmpInput *jettisonpb.Error
	var tmpInput1 jettisonpb.Error

	var tmpOutput1 models.Error
	var tmpOutput *models.Error

	var inputIsNil bool
	tmpInput = namedInput
	if tmpInput != nil {
		tmpInput1.Code = tmpInput.Code
		tmpInput1.Message = tmpInput.Message
		tmpInput1.Source = tmpInput.Source
		tmpInput1.Parameters = tmpInput.Parameters
	} else {
		inputIsNil = true
	}

	if !inputIsNil {
		tmpOutput1.Code = tmpInput1.Code
		tmpOutput1.Message = tmpInput1.Message
		for i := range tmpInput1.Parameters {
			var tmpOutput2 models.KeyValue

			var tmpInput2 *jettisonpb.KeyValue
			var tmpInput3 jettisonpb.KeyValue

			var tmpOutput3 models.KeyValue

			var inputIsNil1 bool
			tmpInput2 = tmpInput1.Parameters[i]
			if tmpInput2 != nil {
				tmpInput3.Key = tmpInput2.Key
				tmpInput3.Value = tmpInput2.Value
			} else {
				inputIsNil1 = true
			}

			if !inputIsNil1 {
				tmpOutput3.Key = tmpInput3.Key
				tmpOutput3.Value = tmpInput3.Value

			}

			tmpOutput2 = tmpOutput3
			tmpOutput1.Parameters = append(tmpOutput1.Parameters, tmpOutput2)
		}
		tmpOutput1.Source = tmpInput1.Source

		tmpOutput = &tmpOutput1

	}

	namedOutput = tmpOutput

	return namedOutput, nil
}

func KeyValueToProto(namedInput *models.KeyValue) (*jettisonpb.KeyValue, error) {
	var namedOutput *jettisonpb.KeyValue

	var tmpInput *models.KeyValue
	var tmpInput1 models.KeyValue

	var tmpOutput1 jettisonpb.KeyValue
	var tmpOutput *jettisonpb.KeyValue

	var inputIsNil bool
	tmpInput = namedInput
	if tmpInput != nil {
		tmpInput1 = *tmpInput
	} else {
		inputIsNil = true
	}

	if !inputIsNil {
		tmpOutput1.Key = tmpInput1.Key
		tmpOutput1.Value = tmpInput1.Value

		tmpOutput = &tmpOutput1

	}

	namedOutput = tmpOutput

	return namedOutput, nil
}

func KeyValueFromProto(namedInput *jettisonpb.KeyValue) (*models.KeyValue, error) {
	var namedOutput *models.KeyValue

	var tmpInput *jettisonpb.KeyValue
	var tmpInput1 jettisonpb.KeyValue

	var tmpOutput1 models.KeyValue
	var tmpOutput *models.KeyValue

	var inputIsNil bool
	tmpInput = namedInput
	if tmpInput != nil {
		tmpInput1.Key = tmpInput.Key
		tmpInput1.Value = tmpInput.Value
	} else {
		inputIsNil = true
	}

	if !inputIsNil {
		tmpOutput1.Key = tmpInput1.Key
		tmpOutput1.Value = tmpInput1.Value

		tmpOutput = &tmpOutput1

	}

	namedOutput = tmpOutput

	return namedOutput, nil
}
